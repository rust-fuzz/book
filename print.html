<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust Fuzz Book</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Guide on how to fuzz test software written in the Rust programming language">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="cargo-fuzz.html"><strong aria-hidden="true">1.</strong> Fuzzing with cargo-fuzz</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="cargo-fuzz/setup.html"><strong aria-hidden="true">1.1.</strong> Setup</a></li><li class="chapter-item expanded "><a href="cargo-fuzz/tutorial.html"><strong aria-hidden="true">1.2.</strong> Tutorial</a></li><li class="chapter-item expanded "><a href="cargo-fuzz/guide.html"><strong aria-hidden="true">1.3.</strong> Guide</a></li><li class="chapter-item expanded "><a href="cargo-fuzz/structure-aware-fuzzing.html"><strong aria-hidden="true">1.4.</strong> Structure-Aware Fuzzing</a></li><li class="chapter-item expanded "><a href="cargo-fuzz/coverage.html"><strong aria-hidden="true">1.5.</strong> Coverage</a></li><li class="chapter-item expanded "><a href="cargo-fuzz/targets.html"><strong aria-hidden="true">1.6.</strong> Targets</a></li></ol></li><li class="chapter-item expanded "><a href="afl.html"><strong aria-hidden="true">2.</strong> Fuzzing with afl.rs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="afl/setup.html"><strong aria-hidden="true">2.1.</strong> Setup</a></li><li class="chapter-item expanded "><a href="afl/tutorial.html"><strong aria-hidden="true">2.2.</strong> Tutorial</a></li></ol></li><li class="chapter-item expanded "><a href="trophy-case.html"><strong aria-hidden="true">3.</strong> Trophy case</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Rust Fuzz Book</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p><a href="https://en.wikipedia.org/wiki/Fuzz_testing">Fuzz testing</a> is a software testing technique used to find security and stability issues by providing pseudo-random data as input to the software.</p>
<p><a href="https://www.rust-lang.org/">Rust</a> is a high performance, safe, general purpose programming language.</p>
<p>This book demonstrates how to perform fuzz testing for software written in Rust.</p>
<p>There are two tools for fuzzing Rust code documented in this book: <strong><a href="afl.html">afl.rs</a></strong> and <strong><a href="cargo-fuzz.html">cargo-fuzz</a></strong>.</p>
<p>The source of this book is available on GitHub at <a href="https://github.com/rust-fuzz/book">https://github.com/rust-fuzz/book</a>.</p>
<h1 id="fuzzing-with-cargo-fuzz"><a class="header" href="#fuzzing-with-cargo-fuzz">Fuzzing with cargo-fuzz</a></h1>
<p><a href="https://github.com/rust-fuzz/cargo-fuzz">cargo-fuzz</a> is the recommended tool for fuzz testing Rust code.</p>
<p>cargo-fuzz is itself not a fuzzer, but a tool to invoke a fuzzer. Currently, the only fuzzer it supports is <a href="http://llvm.org/docs/LibFuzzer.html">libFuzzer</a> (through the <a href="https://github.com/rust-fuzz/libfuzzer-sys">libfuzzer-sys</a> crate), but it could be extended to <a href="https://github.com/rust-fuzz/cargo-fuzz/issues/1">support other fuzzers in the future</a>.</p>
<h1 id="setup"><a class="header" href="#setup">Setup</a></h1>
<h2 id="requirements"><a class="header" href="#requirements">Requirements</a></h2>
<p>libFuzzer needs LLVM sanitizer support, so this only works on x86-64 Linux, x86-64 macOS and Apple-Silicon (aarch64) macOS for now. Requires a C++ compiler with C++11 support. Rust provides multiple compilers. This project requires the nightly compiler since it uses the <code>-Z</code> compiler flag to provide address sanitization. Assuming you used <a href="https://github.com/rust-lang/rustup">rustup</a> to install Rust, you can check your default compiler with:</p>
<pre><code class="language-shell">$ rustup default
stable-x86_64-unknown-linux-gnu (default) # Not the compiler we want.
</code></pre>
<p>To change to the nightly compiler:</p>
<pre><code class="language-shell">$ rustup install nightly
$ rustup default nightly
nightly-x86_64-unknown-linux-gnu (default) # The correct compiler.
</code></pre>
<h2 id="installing"><a class="header" href="#installing">Installing</a></h2>
<pre><code class="language-sh">cargo install cargo-fuzz
</code></pre>
<h2 id="upgrading"><a class="header" href="#upgrading">Upgrading</a></h2>
<pre><code class="language-sh">cargo install --force cargo-fuzz
</code></pre>
<h1 id="tutorial"><a class="header" href="#tutorial">Tutorial</a></h1>
<p>For this tutorial, we're going to be fuzzing the URL parsing crate <a href="https://github.com/servo/rust-url">rust-url</a>. Our goal here is to find some input generated by the fuzzer such that, when passed to <code>Url::parse</code>, it causes some sort of panic or crash to happen.</p>
<p>To start, clone the rust-url repository and change directories into it:</p>
<pre><code class="language-sh">git clone https://github.com/servo/rust-url.git
cd rust-url
</code></pre>
<p>Although we could fuzz the latest commit on <code>master</code>, we're going to checkout a specific revision that is known to have a parsing bug:</p>
<pre><code class="language-sh">git checkout bfa167b4e0253642b6766a7aa74a99df60a94048
</code></pre>
<p>Initialize cargo-fuzz:</p>
<pre><code class="language-sh">cargo fuzz init
</code></pre>
<p>This will create a directory called <code>fuzz_targets</code> which will contain a collection of <em>fuzzing targets</em>. It is generally a good idea to check in the files generated by <code>init</code>. Each fuzz target is a Rust program that is given random data and tests a crate (in this case, rust-url). <code>cargo fuzz init</code> automatically generates an initial fuzz target for us.
Use <code>cargo fuzz list</code> to view the list of all existing fuzz targets:</p>
<pre><code class="language-sh">cargo fuzz list
</code></pre>
<p>The source code for this fuzz target by default lives in <code>fuzz/fuzz_targets/&lt;fuzz target name&gt;.rs</code>. Open that file and edit it to look like this:</p>
<pre><code class="language-rust ignore">#![no_main]
#[macro_use] extern crate libfuzzer_sys;
extern crate url;

fuzz_target!(|data: &amp;[u8]| {
    if let Ok(s) = std::str::from_utf8(data) {
        let _ = url::Url::parse(s);
    }
});
</code></pre>
<p><code>libFuzzer</code> is going to repeatedly call the body of <code>fuzz_target!()</code> with a slice of pseudo-random bytes, until your program hits an error condition (segfault, panic, etc). Write your <code>fuzz_target!()</code> body to hit the entry point you need.</p>
<p>Since the generated data is a byte slice, we'll need to convert it to a UTF-8 <code>&amp;str</code> since rust-url expects that when parsing.</p>
<p>To begin fuzzing, run:</p>
<pre><code class="language-sh">cargo fuzz run &lt;fuzz target name&gt;
</code></pre>
<p>Congratulations, you're fuzzing! The output you're seeing is generated by the fuzzer <a href="http://llvm.org/docs/LibFuzzer.html">libFuzzer</a>. To learn more about what the output means <a href="http://llvm.org/docs/LibFuzzer.html#output">see the 'output' section in the libFuzzer documentation</a>.</p>
<p>If you leave it going for long enough you'll eventually discover a crash. The output would look something like this:</p>
<pre><code class="language-txt">...
#56232	NEW    cov: 2066 corp: 110/4713b exec/s: 11246 rss: 170Mb L: 42 MS: 1 EraseBytes-
#58397	NEW    cov: 2069 corp: 111/4755b exec/s: 11679 rss: 176Mb L: 42 MS: 1 EraseBytes-
#59235	NEW    cov: 2072 corp: 112/4843b exec/s: 11847 rss: 178Mb L: 88 MS: 4 InsertByte-ChangeBit-CopyPart-CopyPart-
#60882	NEW    cov: 2075 corp: 113/4953b exec/s: 12176 rss: 183Mb L: 110 MS: 1 InsertRepeatedBytes-
thread '&lt;unnamed&gt;' panicked at 'index out of bounds: the len is 1 but the index is 1', src/host.rs:105
note: Run with `RUST_BACKTRACE=1` for a backtrace.
==70997== ERROR: libFuzzer: deadly signal
    #0 0x1097c5500 in __sanitizer_print_stack_trace (libclang_rt.asan_osx_dynamic.dylib:x86_64+0x62500)
    #1 0x108383d1b in fuzzer::Fuzzer::CrashCallback() (fuzzer_script_1:x86_64+0x10002fd1b)
    #2 0x108383ccd in fuzzer::Fuzzer::StaticCrashSignalCallback() (fuzzer_script_1:x86_64+0x10002fccd)
    #3 0x1083d19c7 in fuzzer::CrashHandler(int, __siginfo*, void*) (fuzzer_script_1:x86_64+0x10007d9c7)
    ...
    #33 0x10838b393 in fuzzer::Fuzzer::Loop() (fuzzer_script_1:x86_64+0x100037393)
    #34 0x1083650ec in fuzzer::FuzzerDriver(int*, char***, int (*)(unsigned char const*, unsigned long)) (fuzzer_script_1:x86_64+0x1000110ec)
    #35 0x108396c3f in main (fuzzer_script_1:x86_64+0x100042c3f)
    #36 0x7fff91552234 in start (libdyld.dylib:x86_64+0x5234)

NOTE: libFuzzer has rudimentary signal handlers.
      Combine libFuzzer with AddressSanitizer or similar for better crash reports.
SUMMARY: libFuzzer: deadly signal
MS: 2 InsertByte-EraseBytes-; base unit: 3c4fc9770beb5a732d1b78f38cc8b62b20cb997c
0x68,0x74,0x74,0x70,0x3a,0x2f,0x2f,0x5b,0x3a,0x5d,0x3a,0x78,0xc5,0xa4,0x1,0x3a,0x7f,0x1,0x59,0xc5,0xa4,0xd,0x78,0x78,0x3a,0x78,0x69,0x3a,0x0,0x69,0x3a,0x5c,0xd,0x7e,0x78,0x40,0x0,0x25,0xa,0x0,0x29,0x20,
http://[:]:x\xc5\xa4\x01:\x7f\x01Y\xc5\xa4\x0dxx:xi:\x00i:\\\x0d~x@\x00%\x0a\x00)
artifact_prefix='/private/tmp/rust-url/fuzz/artifacts/fuzzer_script_1/'; Test unit written to /home/user/rust-url/fuzz/artifacts/fuzzer_script_1/crash-e9b1b5183e46a288c25a2a073262cdf35408f697
Base64: aHR0cDovL1s6XTp4xaQBOn8BWcWkDXh4OnhpOgBpOlwNfnhAACUKACkg
</code></pre>
<p>The line in the output that starts with <code>http</code> is the input that <a href="https://github.com/servo/rust-url/pull/108">causes a panic in rust-url</a>.</p>
<h1 id="guide"><a class="header" href="#guide">Guide</a></h1>
<p>All available commands available for cargo-fuzz:</p>
<pre><code class="language-sh">cargo fuzz --help
</code></pre>
<p>Run a target:</p>
<pre><code class="language-sh">cargo fuzz run &lt;fuzz target name&gt;
</code></pre>
<h2 id="cargo-features"><a class="header" href="#cargo-features">Cargo features</a></h2>
<p>It is possible to fuzz crates with different configurations of Cargo features by using the command line options <code>--features</code>, <code>--no-default-features</code> and <code>--all-features</code>. Note that these options control the <code>fuzz_targets</code> crate; you will need to forward them to the crate being fuzzed by e.g. adding the following to <code>fuzz_targets/Cargo.toml</code>:</p>
<pre><code class="language-toml">[features]
unsafe = [&quot;project/unsafe&quot;]
</code></pre>
<h2 id="cfgfuzzing"><a class="header" href="#cfgfuzzing"><code>#[cfg(fuzzing)]</code></a></h2>
<p>Every crate instrumented for fuzzing -- the <code>fuzz_targets</code> crate, the project crate, and their entire dependency tree -- is compiled with the <code>--cfg fuzzing</code> rustc option. This makes it possible to disable code paths that prevent fuzzing from working, e.g. verification of cryptographic signatures, with a simple <code>#[cfg(not(fuzzing))]</code>, and without the need for an externally visible Cargo feature that must be maintained throughout every dependency.</p>
<h2 id="cfgfuzzing_repro"><a class="header" href="#cfgfuzzing_repro"><code>#[cfg(fuzzing_repro)]</code></a></h2>
<p>When you run <code>cargo fuzz &lt;fuzz target name&gt; &lt;crash file&gt;</code>, every crate is compiled with the <code>--cfg fuzzing_repro</code> rustc option. This allows you to leave debugging statements in your fuzz targets behind a <code>#[cfg(fuzzing_repro)]</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(fuzzing_repro)]
eprintln!(&quot;Input data: {}&quot;, expensive_pretty_print(&amp;data));
<span class="boring">}
</span></code></pre></pre>
<h2 id="libfuzzer-configuration-options"><a class="header" href="#libfuzzer-configuration-options">libFuzzer configuration options</a></h2>
<p>See all the libFuzzer options:</p>
<pre><code class="language-sh">cargo fuzz run &lt;fuzz target name&gt; -- -help=1
</code></pre>
<p>For example, to generate only ASCII inputs, run:</p>
<pre><code class="language-sh">cargo fuzz run &lt;fuzz target name&gt; -- -only_ascii=1
</code></pre>
<h1 id="structure-aware-fuzzing"><a class="header" href="#structure-aware-fuzzing">Structure-Aware Fuzzing</a></h1>
<p>Not every fuzz target wants to take a buffer of raw bytes as input. We might
want to only feed it well-formed instances of some structured data. Luckily, the
<code>libfuzzer-sys</code> crate enables us to define fuzz targets that take any kind of type,
as long as it implements <a href="https://docs.rs/arbitrary/*/arbitrary/trait.Arbitrary.html">the <code>Arbitrary</code> trait</a>.</p>
<pre><code class="language-rust ignore">libfuzzer_sys::fuzz_target!(|input: AnyTypeThatImplementsArbitrary| {
    // Use `input` here...
})
</code></pre>
<p>The <code>arbitrary</code> crate implements <code>Arbitrary</code> for nearly all the types in <code>std</code>,
including collections like <code>Vec</code> and <code>HashMap</code> as well as things like <code>String</code>
and <code>PathBuf</code>.</p>
<p>For convenience, the <code>libfuzzer-sys</code> crate re-exports the <code>arbitrary</code> crate as
<code>libfuzzer_sys::arbitrary</code>. You can also enable <code>#[derive(Arbitrary)]</code> either by</p>
<ul>
<li>enabling the <code>arbitary</code> crate's <code>&quot;derive&quot;</code> feature, or</li>
<li>(equivalently) enabling the <code>libfuzzer-sys</code> crate's <code>&quot;arbitrary-derive&quot;</code> feature.</li>
</ul>
<p><a href="https://docs.rs/arbitrary">See the <code>arbitrary</code> crate's documentation for more details.</a></p>
<p>This section concludes with two examples of structure-aware fuzzing:</p>
<ol>
<li>
<p><a href="cargo-fuzz/structure-aware-fuzzing.html#example-1-fuzzing-color-conversions">Example 1: Fuzzing Color Conversions</a></p>
</li>
<li>
<p><a href="cargo-fuzz/structure-aware-fuzzing.html#example-2-fuzzing-allocator-api-calls">Example 2: Fuzzing Allocation API Calls</a></p>
</li>
</ol>
<h2 id="example-1-fuzzing-color-conversions"><a class="header" href="#example-1-fuzzing-color-conversions">Example 1: Fuzzing Color Conversions</a></h2>
<p>Let's say we are working on a color conversion library that can turn RGB colors
into HSL and back again.</p>
<h3 id="enable-deriving-arbitrary"><a class="header" href="#enable-deriving-arbitrary">Enable Deriving <code>Arbitrary</code></a></h3>
<p>We are lazy, and don't want to implement <code>Arbitrary</code> by hand, so we want to
enable the <code>arbitrary</code> crate's <code>&quot;derive&quot;</code> cargo feature. This lets us get
automatic <code>Arbitrary</code> implementations with <code>#[derive(Arbitrary)]</code>.</p>
<p>Because the <code>Rgb</code> type we will be deriving <code>Arbitrary</code> for is in our main color
conversion crate, we add this to our main <code>Cargo.toml</code>.</p>
<pre><code class="language-toml"># Cargo.toml

[dependencies]
arbitrary = { version = &quot;1&quot;, optional = true, features = [&quot;derive&quot;] }
</code></pre>
<h3 id="derive-arbitrary-for-our-rgb-type"><a class="header" href="#derive-arbitrary-for-our-rgb-type">Derive <code>Arbitrary</code> for our <code>Rgb</code> Type</a></h3>
<p>In our main crate, when the <code>&quot;arbitrary&quot;</code> cargo feature is enabled, we derive
the <code>Arbitrary</code> trait:</p>
<pre><code class="language-rust ignore">// src/lib.rs

#[derive(Clone, Debug)]
#[cfg_attr(feature = &quot;arbitrary&quot;, derive(arbitrary::Arbitrary))]
pub struct Rgb {
    pub r: u8,
    pub g: u8,
    pub b: u8,
}
</code></pre>
<h3 id="enable-the-main-projects-arbitrary-cargo-feature-for-the-fuzz-targets"><a class="header" href="#enable-the-main-projects-arbitrary-cargo-feature-for-the-fuzz-targets">Enable the Main Project's <code>&quot;arbitrary&quot;</code> Cargo Feature for the Fuzz Targets</a></h3>
<p>Because we made <code>arbitrary</code> an optional dependency in our main color conversion
crate, we need to enable that feature for our fuzz targets to use it.</p>
<pre><code class="language-toml"># fuzz/Cargo.toml

[dependencies]
my_color_conversion_library = { path = &quot;..&quot;, features = [&quot;arbitrary&quot;] }
</code></pre>
<h3 id="add-the-fuzz-target"><a class="header" href="#add-the-fuzz-target">Add the Fuzz Target</a></h3>
<p>We need to add a new fuzz target to our project:</p>
<pre><code class="language-sh">$ cargo fuzz add rgb_to_hsl_and_back
</code></pre>
<h3 id="implement-the-fuzz-target"><a class="header" href="#implement-the-fuzz-target">Implement the Fuzz Target</a></h3>
<p>Finally, we can implement our fuzz target that takes arbitrary RGB colors,
converts them to HSL, and then converts them back to RGB and asserts that we get
the same color as the original! Because we implement <code>Arbitrary</code> for our <code>Rgb</code>
type, our fuzz target can take instances of <code>Rgb</code> directly:</p>
<pre><code class="language-rust ignore">// fuzz/fuzz_targets/rgb_to_hsl_and_back.rs

libfuzzer_sys::fuzz_target!(|color: Rgb| {
    let hsl = color.to_hsl();
    let rgb = hsl.to_rgb();

    // This should be true for all RGB -&gt; HSL -&gt; RGB conversions!
    assert_eq!(color, rgb);
});
</code></pre>
<h2 id="example-2-fuzzing-allocator-api-calls"><a class="header" href="#example-2-fuzzing-allocator-api-calls">Example 2: Fuzzing Allocator API Calls</a></h2>
<p>Imagine, for example, that we are fuzzing our own <code>malloc</code> and <code>free</code>
implementation. We want to make a sequence of valid allocation and deallocation
API calls. Additionally, we want that sequence to be guided by the fuzzer, so it
can use its insight into code coverage to maximize the amount of code we
exercise during fuzzing.</p>
<h3 id="add-the-fuzz-target-1"><a class="header" href="#add-the-fuzz-target-1">Add the Fuzz Target</a></h3>
<p>First, we add a new fuzz target to our project:</p>
<pre><code class="language-sh">$ cargo fuzz add fuzz_malloc_free
</code></pre>
<h3 id="enable-deriving-arbitrary-1"><a class="header" href="#enable-deriving-arbitrary-1">Enable Deriving <code>Arbitrary</code></a></h3>
<p>Like the color conversion example above, we don't want to write our <code>Arbitrary</code>
implementation by hand, we want to derive it.</p>
<pre><code class="language-toml"># fuzz/Cargo.toml

[dependencies]
libfuzzer-sys = { version = &quot;0.4.0&quot;, features = [&quot;arbitrary-derive&quot;] }
</code></pre>
<h3 id="define-an-allocatormethod-type-and-derive-arbitrary"><a class="header" href="#define-an-allocatormethod-type-and-derive-arbitrary">Define an <code>AllocatorMethod</code> Type and Derive <code>Arbitrary</code></a></h3>
<p>Next, we define an <code>enum</code> that represents either a <code>malloc</code>, a <code>realloc</code>, or a
<code>free</code>:</p>
<pre><code class="language-rust ignore">// fuzz_targets/fuzz_malloc_free.rs

use libfuzzer_sys::arbitrary::Arbitrary;

#[derive(Arbitrary, Debug)]
enum AllocatorMethod {
    Malloc {
        // The size of allocation to make.
        size: usize,
    },
    Free {
        // Free the index^th allocation we've made.
        index: usize
    },
    Realloc {
        // We will realloc the index^th allocation we've made.
        index: usize,
        // The new size of the allocation.
        new_size: usize,
    },
}
</code></pre>
<h3 id="write-a-fuzz-target-that-takes-a-sequence-of-allocatormethods"><a class="header" href="#write-a-fuzz-target-that-takes-a-sequence-of-allocatormethods">Write a Fuzz Target That Takes a Sequence of <code>AllocatorMethod</code>s</a></h3>
<p>Finally, we write a fuzz target that takes a vector of <code>AllocatorMethod</code>s and
interprets them by making the corresponding <code>malloc</code>, <code>realloc</code>, and <code>free</code>
calls. This works because <code>Vec&lt;T&gt;</code> implements <code>Arbitrary</code> when <code>T</code> implements
<code>Arbitrary</code>.</p>
<pre><code class="language-rust ignore">// fuzz/fuzz_targets/fuzz_malloc_free.rs

libfuzzer_sys::fuzz_target!(|methods: Vec&lt;AllocatorMethod&gt;| {
    let mut allocs = vec![];

    // Interpret the fuzzer-provided methods and make the
    // corresponding allocator API calls.
    for method in methods {
        match method {
            AllocatorMethod::Malloc { size } =&gt; {
                let ptr = my_allocator::malloc(size);
                allocs.push(ptr);
            }
            AllocatorMethod::Free { index } =&gt; {
                match allocs.get(index) {
                    Some(ptr) if !ptr.is_null() =&gt; {
                        my_allocator::free(ptr);
                        allocs[index] = std::ptr::null();
                    }
                    _ =&gt; {}
                }
            }
            AllocatorMethod::Realloc { index, size } =&gt; {
                match allocs.get(index) {
                    Some(ptr) if !ptr.is_null() =&gt; {
                        let new_ptr = my_allocator::realloc(ptr, size);
                        allocs[index] = new_ptr;
                    }
                    _ =&gt; {}
                }
            }
        }
    }

    // Free any remaining allocations.
    for ptr in allocs {
        if !ptr.is_null() =&gt; {
            my_allocator::free(ptr);
        }
    }
});
</code></pre>
<h1 id="code-coverage"><a class="header" href="#code-coverage">Code Coverage</a></h1>
<p>Visualizing code coverage helps you understand which code paths are being fuzzed
and — more importantly — which aren't. To help the fuzzer exercise
new code paths, you can look at what it is failing to reach and then either add
new seed inputs to the corpus, or tweak the fuzz target. This chapter describes
how to generate coverage reports for your fuzz target and its current corpus.</p>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<p>First, install the LLVM-coverage tools as described in the <a href="https://doc.rust-lang.org/stable/rustc/instrument-coverage.html#installing-llvm-coverage-tools">rustc book</a>.</p>
<p>If you are using a non-nightly toolchain as your default toolchain, remember to
install the rustup components for the nightly toolchain instead of the default
(<code>rustup component add --toolchain nightly llvm-tools-preview ...</code>).</p>
<p>You must also have <code>cargo fuzz</code> version <code>0.10.0</code> or newer to use the <code>cargo fuzz coverage</code> subcommand.</p>
<h2 id="generate-code-coverage-data"><a class="header" href="#generate-code-coverage-data">Generate Code-Coverage Data</a></h2>
<p>After you fuzzed your program, use the <code>coverage</code> command to generate precise
<a href="https://blog.rust-lang.org/inside-rust/2020/11/12/source-based-code-coverage.html">source-based code coverage</a> information:</p>
<pre><code class="language-shell">$ cargo fuzz coverage &lt;target&gt; [corpus dirs] [-- &lt;args&gt;]
</code></pre>
<p>This command</p>
<ul>
<li>
<p>compiles your project using the <code>-Cinstrument-coverage</code> Rust compiler flag,</p>
</li>
<li>
<p>runs the program <em>without fuzzing</em> on the provided corpus (if no corpus
directory is provided it uses <code>fuzz/corpus/&lt;target&gt;</code> by default),</p>
</li>
<li>
<p>for each input file in the corpus, generates raw coverage data in the
<code>fuzz/coverage/&lt;target&gt;/raw</code> subdirectory, and</p>
</li>
<li>
<p>merges the raw files into a <code>coverage.profdata</code> file located in the
<code>fuzz/coverage/&lt;target&gt;</code> subdirectory.</p>
</li>
</ul>
<p>Afterwards, you can use the generated <code>coverage.profdata</code> file to generate
coverage reports and visualize code-coverage information as described in the
<a href="https://doc.rust-lang.org/stable/rustc/instrument-coverage.html#running-the-instrumented-binary-to-generate-raw-coverage-profiling-data">rustc book</a>.</p>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<p>Suppose we have a <code>my_compiler</code> fuzz target for which we want to visualize code
coverage.</p>
<ol>
<li>
<p>Run the fuzzer on the <code>my_compiler</code> target:</p>
<pre><code class="language-shell">$ cargo fuzz run my_compiler
</code></pre>
</li>
<li>
<p>Produce code-coverage information:</p>
<pre><code class="language-shell">$ cargo fuzz coverage my_compiler
</code></pre>
</li>
<li>
<p>Visualize the coverage data in HTML:</p>
<pre><code class="language-shell">$ cargo cov -- show fuzz/target/&lt;target triple&gt;/release/my_compiler \
    --format=html \
    -instr-profile=fuzz/coverage/my_compiler/coverage.profdata \
    &gt; index.html
</code></pre>
<p>There are many visualization and coverage-report options available (see <code>llvm-cov show --help</code>).</p>
</li>
</ol>
<h1 id="targets"><a class="header" href="#targets">Targets</a></h1>
<p>A collection of community maintained cargo-fuzz compatible fuzz targets can be found <a href="https://github.com/rust-fuzz/targets">here</a>.</p>
<h1 id="fuzzing-with-aflrs"><a class="header" href="#fuzzing-with-aflrs">Fuzzing with afl.rs</a></h1>
<p><a href="http://lcamtuf.coredump.cx/afl/">American fuzzy lop</a> (AFL) is a popular, effective, and modern fuzz testing tool. <a href="https://github.com/rust-fuzz/afl.rs">afl.rs</a> allows one to run AFL on code written in <a href="https://www.rust-lang.org">the Rust programming language</a>.</p>
<h1 id="setup-1"><a class="header" href="#setup-1">Setup</a></h1>
<h2 id="requirements-1"><a class="header" href="#requirements-1">Requirements</a></h2>
<h3 id="tools"><a class="header" href="#tools">Tools</a></h3>
<ul>
<li>C compiler (e.g. gcc or clang)</li>
<li>make</li>
</ul>
<h3 id="platform"><a class="header" href="#platform">Platform</a></h3>
<p>afl.rs works on x86-64 Linux, x86-64 macOS, and ARM64 macOS.</p>
<pre><code class="language-sh">cargo install afl
</code></pre>
<h2 id="upgrading-1"><a class="header" href="#upgrading-1">Upgrading</a></h2>
<pre><code class="language-sh">cargo install --force afl
</code></pre>
<h1 id="tutorial-1"><a class="header" href="#tutorial-1">Tutorial</a></h1>
<p>For this tutorial, we are going to fuzz the URL parser <a href="https://github.com/servo/rust-url">rust-url</a>. Our goal here is to find some input generated by the fuzzer such that, when passed to <a href="https://docs.rs/url/*/url/struct.Url.html#method.parse"><code>Url::parse</code></a>, it causes some sort of panic or crash to happen.</p>
<h2 id="create-a-fuzz-target"><a class="header" href="#create-a-fuzz-target">Create a fuzz target</a></h2>
<p>The first thing we’ll do is create a <em>fuzz target</em> in the form of a Rust binary crate. AFL will call the resulting binary, supplying generated bytes to standard input that we’ll pass to <code>Url::parse</code>.</p>
<pre><code class="language-sh">cargo new --bin url-fuzz-target
cd url-fuzz-target
</code></pre>
<p>We’ll need two dependencies in this crate:</p>
<ul>
<li><code>url</code>: the crate we’re fuzzing</li>
<li><code>afl</code>: not required, but includes a couple utility functions to assist in creating fuzz targets</li>
</ul>
<p>So add these to the <code>Cargo.toml</code> file:</p>
<pre><code class="language-toml">[dependencies]
afl = &quot;*&quot;
url = &quot;*&quot;
</code></pre>
<p>Now we’ll need to write the source for the fuzz target in <code>src/main.rs</code>:</p>
<pre><code class="language-rust ignore">#[macro_use]
extern crate afl;
extern crate url;

fn main() {
    fuzz!(|data: &amp;[u8]| {
        if let Ok(s) = std::str::from_utf8(data) {
            let _ = url::Url::parse(&amp;s);
        }
    });
}
</code></pre>
<p><a href="https://docs.rs/afl/*/afl/macro.fuzz.html"><code>fuzz!</code></a> is a utility macro provided by the <code>afl</code> crate that reads bytes from standard input and
passes the bytes to the provided closure.</p>
<p>In the body of the closure, we call <code>Url::parse</code> with the bytes that AFL generated. If all goes well, <code>url::Url::parse</code> will return an <code>Ok</code> containing a valid <code>Url</code>, or an <code>Err</code> indicating a <code>Url</code> could not be constructed from the <code>String</code>. If <code>Url::parse</code> panics while parsing the <code>String</code>, AFL will treat it as a crash and the AFL UI will indicate as such.</p>
<p>One important detail about the <a href="https://docs.rs/afl/*/afl/macro.fuzz.html"><code>fuzz!</code></a> macro: if a panic occurs within the body of the closure, the panic will be <a href="https://doc.rust-lang.org/std/panic/fn.catch_unwind.html">caught</a> and <a href="https://doc.rust-lang.org/std/process/fn.abort.html"><code>process::abort</code></a> will be subsequently called. Without the call to <a href="https://doc.rust-lang.org/std/process/fn.abort.html"><code>process::abort</code></a>, AFL would not consider the unwinding panic to be a crash.</p>
<h2 id="build-the-fuzz-target"><a class="header" href="#build-the-fuzz-target">Build the fuzz target</a></h2>
<p>Normally, one uses <code>cargo build</code> to compile a Cargo-based Rust project. To get AFL to work with Rust, a few extra compiler flags need to be passed to rustc during the build process. To make this easier, there is an AFL cargo subcommand (provided by the <code>afl</code> crate) that automatically passes these rustc flags for us. To use it, you’ll do something like:</p>
<pre><code class="language-sh">cargo afl &lt;cargo command&gt;
</code></pre>
<p>Since we want to build this crate, we’ll run:</p>
<pre><code class="language-sh">cargo afl build
</code></pre>
<h2 id="provide-starting-inputs"><a class="header" href="#provide-starting-inputs">Provide starting inputs</a></h2>
<p>AFL doesn't strictly require starting inputs, but providing some can make AFL’s job easier since it won’t need to ‘learn’ what a valid URL looks like. To do this, we'll create a directory called <code>in</code> with a few files (filenames don’t matter) containing valid URLs:</p>
<pre><code class="language-sh">mkdir in
echo &quot;tcp://example.com/&quot; &gt; in/url
echo &quot;ssh://192.168.1.1&quot; &gt; in/url2
echo &quot;http://www.example.com:80/foo?hi=bar&quot; &gt; in/url3
</code></pre>
<h2 id="start-fuzzing"><a class="header" href="#start-fuzzing">Start fuzzing</a></h2>
<p>To begin fuzzing, we’ll run:</p>
<pre><code class="language-sh">cargo afl fuzz -i in -o out target/debug/url-fuzz-target
</code></pre>
<p>The <code>fuzz</code> subcommand of <code>cargo-afl</code> is the primary interface for fuzzing Rust code with AFL. For those already familiar with AFL, the <code>fuzz</code> subcommand of <code>cargo-afl</code> is identical to running <code>afl-fuzz</code>.</p>
<p>The <code>-i</code> flag specifies a directory full of input files AFL will use as seeds.</p>
<p>The <code>-o</code> flag specifies a directory AFL will write all its state and results to.</p>
<p>The last argument <code>target/debug/url-fuzz-target</code> specifies the fuzz target binary AFL will call, supplying random bytes to standard input.</p>
<p>As soon as you run this command, you should see AFL’s interface start up:</p>
<p><img src="https://raw.githubusercontent.com/rust-fuzz/afl.rs/master/etc/screencap.gif" alt="" /></p>
<p>For more information about this UI and what each of the sections mean, see <a href="http://lcamtuf.coredump.cx/afl/status_screen.txt">this resource hosted on the AFL website</a>.</p>
<p>AFL will run indefinitely, so if you want to quit, press <code>CTRL-C</code>.</p>
<h2 id="reproducing"><a class="header" href="#reproducing">Reproducing</a></h2>
<p>Once you have a few crashes collected from running your fuzzer, you can reproduce them by passing them in manually to your test case. This is typically done via <code>stdin</code>. E.g. for <code>url-fuzz-target</code> the command would be:</p>
<pre><code class="language-sh">cargo afl run url-fuzz-target &lt; out/default/crashes/crash_file
</code></pre>
<p>where <code>out</code> is the <code>-o</code> parameter from your fuzz command and <code>crash_file</code> is an arbitrary file in the <code>crashes</code> directory.</p>
<h1 id="trophy-case"><a class="header" href="#trophy-case">Trophy Case</a></h1>
<p>A collection of bugs found in Rust code through fuzz testing can be found in <a href="https://github.com/rust-fuzz/trophy-case">the trophy-case repository</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
